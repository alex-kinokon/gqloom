---
title: 快速上手
icon: PencilRuler
---

为了快速上手 GQLoom，我们将一起搭建一个简单的 GraphQL 后端应用。

我们将搭建一个猫舍应用，并为向外部提供 GraphQL API。
该应用将包含一些简单的功能：
- 猫基础信息管理：录入猫的的基本信息，包括名称、生日等，更新、删除和查询猫；
- 用户（猫主人）登记管理：录入用户信息，简单的登录功能，查看用户的猫；

我们将使用以下技术：
- [TypeScript](https://www.typescriptlang.org/): 作为我们的开发语言；
- [Node.js](https://nodejs.org/): 作为我们应用的运行时；
- [graphql.js](https://github.com/graphql/graphql-js): GraphQL 的 JavaScript 实现；
- [GraphQL Yoga](https://the-guild.dev/graphql/yoga-server): 功能全面的 GraphQL HTTP 适配器；
- [Drizzle ORM](https://orm.drizzle.team/): 一个快速且类型安全的 ORM，帮助我们操作数据库；
- [Valibot](https://valibot.dev/) 或者 [Zod](https://zod.dev/): 用于定义和验证输入；
- `GQLoom`: 让我们舒适且高效地定义 GraphQL Schema 并编写解析器（Resolver）；

## 前提条件

我们只需要安装版本 20 以上的 [Node.js](https://nodejs.org/) 来运行我们的应用。

## 创建应用

### 初始化项目

首先，让我们新建文件夹并初始化项目：

<Tabs groupId="package-manager" items={["npm", "pnpm" , "yarn"]}>
<Tab>
```sh
mkdir cattery
cd ./cattery
npm init -y
```
</Tab>
<Tab>
```sh
mkdir cattery
cd ./cattery
pnpm init
```
</Tab>
<Tab>
```sh
mkdir cattery
cd ./cattery
yarn init -y
```
</Tab>
</Tabs>

然后，我们将安装一些必要的依赖来以便在 Node.js 运行中 TypeScript 应用：

<Tabs groupId="package-manager" items={["npm", "pnpm" , "yarn"]}>
<Tab>
```sh
npm i -D typescript @types/node tsx
npx tsc --init
```
</Tab>
<Tab>
```sh
pnpm add -D typescript @types/node tsx
pnpm exec tsc --init
```
</Tab>
<Tab>
```sh
yarn add -D typescript @types/node tsx
yarn dlx -q -p typescript tsc --init
```
</Tab>
</Tabs>

接下来，我们将安装 GQLoom 以及相关依赖，我们可以选择 [Valibot](https://valibot.dev/) 或者 [Zod](https://zod.dev/) 来定义并验证输入：

<Tabs groupId="package-manager" items={["npm", "pnpm" , "yarn"]}>
<Tab>
```sh
# use Valibot
npm i graphql graphql-yoga @gqloom/core valibot @gqloom/valibot

# use Zod
npm i graphql graphql-yoga @gqloom/core zod @gqloom/zod
```
</Tab>
<Tab>
```sh
# use Valibot
pnpm add graphql graphql-yoga @gqloom/core valibot @gqloom/valibot

# use Zod
pnpm add graphql graphql-yoga @gqloom/core zod @gqloom/zod
```
</Tab>
<Tab>
```sh
# use Valibot
yarn add graphql graphql-yoga @gqloom/core valibot @gqloom/valibot

# use zod
yarn add graphql graphql-yoga @gqloom/core zod @gqloom/zod
```
</Tab>
</Tabs>

### 你好，世界

让我们编写第一个[解析器](./resolver):

```ts twoslash title="src/resolvers/index.ts"
import { query, resolver } from "@gqloom/core"
import { z } from "zod"

const helloResolver = resolver({
  hello: query(z.string())
    .input({
      name: z
        .string()
        .nullish()
        .transform((x) => x ?? "World"),
    })
    .resolve(({ name }) => `Hello ${name}!`),
})

export const resolvers = [helloResolver]
```

我们需要将这个解析器编织成 GraphQL Schema，并以 HTTP 服务器的形式运行它：

```ts twoslash title="src/index.ts"
// @filename: resolvers.ts
import { query, resolver } from "@gqloom/core"
import { z } from "zod"

const helloResolver = resolver({
  hello: query(z.string())
    .input({
      name: z
        .string()
        .nullish()
        .transform((x) => x ?? "World"),
    })
    .resolve(({ name }) => `Hello ${name}!`),
})

export const resolvers = [helloResolver]
// @filename: index.ts
// ---cut---
import { createServer } from "node:http"
import { weave } from "@gqloom/core"
import { ZodWeaver } from "@gqloom/zod"
import { createYoga } from "graphql-yoga"
import { resolvers } from "./resolvers"

const schema = weave(ZodWeaver, ...resolvers)

const yoga = createYoga({ schema })
createServer(yoga).listen(4000, () => {
  console.info("Server is running on http://localhost:4000/graphql")
})
```

很好，我们已经创建了一个简单的 GraphQL 应用。  
接下来我们尝试运行这个应用，在 `package.json` 里添加 `dev` 脚本：
```json
{
  "scripts": {
    "dev": "tsx watch src/index.ts"
  }
}
```

现在让我们运行一下：

<Tabs groupId="package-manager" items={["npm", "pnpm" , "yarn"]}>
<Tab>
```sh
npm run dev
```
</Tab>
<Tab>
```sh
pnpm dev
```
</Tab>
<Tab>
```sh
yarn dev
```
</Tab>
</Tabs>

在浏览器中打开 http://localhost:4000/graphql 就可以看到 GraphQL 演练场了。  
让我们尝试发送一个 GraphQL 查询，在演练场里输入:

```gql title="GraphQL Query" 
{
  hello(name: "GQLoom")
}
```

点击查询按钮，就可以看到结果了：

```json
{
  "data": {
    "hello": "Hello GQLoom!"
  }
}
```

到此为止，我们已经创建了一个最简单的 GraphQL 应用。

接下来我们将使用 Drizzle ORM 来与数据库交互并添加完整的功能。

## 初始化数据库和表格

首先，让我们安装 [Drizzle ORM](https://orm.drizzle.team/)，我们将使用它来操作 **SQLite** 数据库。

<Tabs groupId="package-manager" items={["npm", "pnpm" , "yarn"]}>
<Tab>
```sh
npm i @gqloom/drizzle drizzle-orm @libsql/client dotenv
npm i -D drizzle-kit
```
</Tab>
<Tab>
```sh
pnpm add @gqloom/drizzle drizzle-orm @libsql/client dotenv
pnpm add -D drizzle-kit
```
</Tab>
<Tab>
```sh
yarn add @gqloom/drizzle drizzle-orm @libsql/client dotenv
yarn add -D drizzle-kit
```
</Tab>
</Tabs>

### 定义数据库表格

接下来在 `src/schema/index.ts` 文件中定义数据库表格，我们将定义 `users` 和 `cats` 两个表格，并建立它们之间的关系：

```ts twoslash title="src/schema/index.ts"
import { drizzleSilk } from "@gqloom/drizzle"
import { relations } from "drizzle-orm"
import * as t from "drizzle-orm/sqlite-core"

export const users = drizzleSilk(
  t.sqliteTable("users", {
    id: t.int().primaryKey({ autoIncrement: true }),
    name: t.text().notNull(),
    phone: t.text().notNull().unique(),
  })
)

export const usersRelations = relations(users, ({ many }) => ({
  cats: many(cats),
}))

export const cats = drizzleSilk(
  t.sqliteTable("cats", {
    id: t.integer().primaryKey({ autoIncrement: true }),
    name: t.text().notNull(),
    birthday: t.integer({ mode: "timestamp" }).notNull(),
    ownerId: t
      .integer()
      .notNull()
      .references(() => users.id),
  })
)

export const catsRelations = relations(cats, ({ one }) => ({
  owner: one(users, {
    fields: [cats.ownerId],
    references: [users.id],
  }),
}))
```

### 初始化数据库

我们需要创建一个配置文件:
```ts twoslash title="drizzle.config.ts"
import "dotenv/config"
import { defineConfig } from "drizzle-kit"

export default defineConfig({
  out: "./drizzle",
  schema: "./src/schema/index.ts",
  dialect: "sqlite",
  dbCredentials: {
    url: process.env.DB_FILE_NAME ?? "file:local.db",
  },
})
```

然后我们运行 `drizzle-kit push` 命令在数据库中建立已定义的表格：
```sh
npx drizzle-kit push
```

### 使用数据库

为了在应用中使用数据库，我们需要创建一个数据库实例：
```ts twoslash title="src/providers/index.ts"
// @filename: schema/index.ts
import { drizzleSilk } from "@gqloom/drizzle"
import { relations } from "drizzle-orm"
import * as t from "drizzle-orm/sqlite-core"

export const users = drizzleSilk(
  t.sqliteTable("users", {
    id: t.int().primaryKey({ autoIncrement: true }),
    name: t.text().notNull(),
    phone: t.text().notNull().unique(),
  })
)

export const usersRelations = relations(users, ({ many }) => ({
  cats: many(cats),
}))

export const cats = drizzleSilk(
  t.sqliteTable("cats", {
    id: t.integer().primaryKey({ autoIncrement: true }),
    name: t.text().notNull(),
    birthday: t.integer({ mode: "timestamp" }).notNull(),
    ownerId: t
      .integer()
      .notNull()
      .references(() => users.id),
  })
)

export const catsRelations = relations(cats, ({ one }) => ({
  owner: one(users, {
    fields: [cats.ownerId],
    references: [users.id],
  }),
}))
// @filename: providers/index.ts
// ---cut---
import { drizzle } from "drizzle-orm/libsql"
import * as schema from "../schema"

export const db = drizzle(process.env.DB_FILE_NAME ?? "file:local.db", {
  schema,
})
```

## 用户解析器

让我们先创建一个用户服务，其中将包含一系列对用户表的操作。
我们将在 `src/services/user.ts` 文件中实现用户服务，并在 `src/resolvers/index.ts` 文件中将整个 `user.ts` 作为 `userService` 导出：

```ts twoslash title="src/services/user.ts" tab="src/services/user.ts"
// @filename: schema/index.ts
import { drizzleSilk } from "@gqloom/drizzle"
import { relations } from "drizzle-orm"
import * as t from "drizzle-orm/sqlite-core"

export const users = drizzleSilk(
  t.sqliteTable("users", {
    id: t.int().primaryKey({ autoIncrement: true }),
    name: t.text().notNull(),
    phone: t.text().notNull().unique(),
  })
)

export const usersRelations = relations(users, ({ many }) => ({
  cats: many(cats),
}))

export const cats = drizzleSilk(
  t.sqliteTable("cats", {
    id: t.integer().primaryKey({ autoIncrement: true }),
    name: t.text().notNull(),
    birthday: t.integer({ mode: "timestamp" }).notNull(),
    ownerId: t
      .integer()
      .notNull()
      .references(() => users.id),
  })
)

export const catsRelations = relations(cats, ({ one }) => ({
  owner: one(users, {
    fields: [cats.ownerId],
    references: [users.id],
  }),
}))
// @filename: providers/index.ts
import { drizzle } from "drizzle-orm/libsql"
import * as schema from "../schema"

export const db = drizzle(process.env.DB_FILE_NAME ?? "file:local.db", {
  schema,
})
// @filename: services/user.ts
// ---cut---
import { eq } from "drizzle-orm"
import { db } from "../providers"
import { users } from "../schema"

export async function createUser(input: typeof users.$inferInsert) {
  const [user] = await db.insert(users).values(input).returning()
  return user
}

export async function findUsersByName(name: string) {
  return await db.query.users.findMany({
    where: eq(users.name, name),
  })
}

export async function findUserByPhone(phone: string) {
  return await db.query.users.findFirst({
    where: eq(users.phone, phone),
  })
}
```
```ts twoslash title="src/services/index.ts" tab="src/services/index.ts"
// @filename: schema/index.ts
import { drizzleSilk } from "@gqloom/drizzle"
import { relations } from "drizzle-orm"
import * as t from "drizzle-orm/sqlite-core"

export const users = drizzleSilk(
  t.sqliteTable("users", {
    id: t.int().primaryKey({ autoIncrement: true }),
    name: t.text().notNull(),
    phone: t.text().notNull().unique(),
  })
)

export const usersRelations = relations(users, ({ many }) => ({
  cats: many(cats),
}))

export const cats = drizzleSilk(
  t.sqliteTable("cats", {
    id: t.integer().primaryKey({ autoIncrement: true }),
    name: t.text().notNull(),
    birthday: t.integer({ mode: "timestamp" }).notNull(),
    ownerId: t
      .integer()
      .notNull()
      .references(() => users.id),
  })
)

export const catsRelations = relations(cats, ({ one }) => ({
  owner: one(users, {
    fields: [cats.ownerId],
    references: [users.id],
  }),
}))
// @filename: providers/index.ts
import { drizzle } from "drizzle-orm/libsql"
import * as schema from "../schema"

export const db = drizzle(process.env.DB_FILE_NAME ?? "file:local.db", {
  schema,
})
// @filename: services/user.ts
// ---cut---
import { eq } from "drizzle-orm"
import { db } from "../providers"
import { users } from "../schema"

export async function createUser(input: typeof users.$inferInsert) {
  const [user] = await db.insert(users).values(input).returning()
  return user
}

export async function findUsersByName(name: string) {
  return await db.query.users.findMany({
    where: eq(users.name, name),
  })
}

export async function findUserByPhone(phone: string) {
  return await db.query.users.findFirst({
    where: eq(users.phone, phone),
  })
}
// @filename: services/index.ts
// ---cut---
export * as userService from "./user"
```

现在，我们可以在解析器中使用用户服务，我们将创建一个用户解析器添加以下操作：

- `usersByName`: 通过名称查找用户
- `userByPhone`: 通过手机号码查找用户
- `createUser`: 创建一个用户

在完成用户解析器后，我们还需要将它添加到 `src/resolvers/index.ts` 文件里的 `resolvers` 中：

```ts twoslash title="src/resolvers/user.ts" tab="src/resolvers/user.ts"
// @filename: schema/index.ts
import { drizzleSilk } from "@gqloom/drizzle"
import { relations } from "drizzle-orm"
import * as t from "drizzle-orm/sqlite-core"

export const users = drizzleSilk(
  t.sqliteTable("users", {
    id: t.int().primaryKey({ autoIncrement: true }),
    name: t.text().notNull(),
    phone: t.text().notNull().unique(),
  })
)

export const usersRelations = relations(users, ({ many }) => ({
  cats: many(cats),
}))

export const cats = drizzleSilk(
  t.sqliteTable("cats", {
    id: t.integer().primaryKey({ autoIncrement: true }),
    name: t.text().notNull(),
    birthday: t.integer({ mode: "timestamp" }).notNull(),
    ownerId: t
      .integer()
      .notNull()
      .references(() => users.id),
  })
)

export const catsRelations = relations(cats, ({ one }) => ({
  owner: one(users, {
    fields: [cats.ownerId],
    references: [users.id],
  }),
}))
// @filename: providers/index.ts
import { drizzle } from "drizzle-orm/libsql"
import * as schema from "../schema"

export const db = drizzle(process.env.DB_FILE_NAME ?? "file:local.db", {
  schema,
})
// @filename: services/user.ts
// ---cut---
import { eq } from "drizzle-orm"
import { db } from "../providers"
import { users } from "../schema"

export async function createUser(input: typeof users.$inferInsert) {
  const [user] = await db.insert(users).values(input).returning()
  return user
}

export async function findUsersByName(name: string) {
  return await db.query.users.findMany({
    where: eq(users.name, name),
  })
}

export async function findUserByPhone(phone: string) {
  return await db.query.users.findFirst({
    where: eq(users.phone, phone),
  })
}
// @filename: services/index.ts
export * as userService from "./user"
// @filename: resolver/user.ts
// ---cut---
import { mutation, query, resolver } from "@gqloom/core"
import { z } from "zod"
import { users } from "../schema"
import { userService } from "../services"

export const userResolver = resolver({
  usersByName: query(users.$list())
    .input({ name: z.string() })
    .resolve(({ name }) => userService.findUsersByName(name)),

  userByPhone: query(users.$nullable())
    .input({ phone: z.string() })
    .resolve(({ phone }) => userService.findUserByPhone(phone)),

  createUser: mutation(users)
    .input({
      data: z.object({
        name: z.string(),
        phone: z.string(),
      }),
    })
    .resolve(async ({ data }) => userService.createUser(data)),
})
```

```ts twoslash title="src/resolvers/index.ts" tab="src/resolvers/index.ts"
// @filename: schema/index.ts
import { drizzleSilk } from "@gqloom/drizzle"
import { relations } from "drizzle-orm"
import * as t from "drizzle-orm/sqlite-core"

export const users = drizzleSilk(
  t.sqliteTable("users", {
    id: t.int().primaryKey({ autoIncrement: true }),
    name: t.text().notNull(),
    phone: t.text().notNull().unique(),
  })
)

export const usersRelations = relations(users, ({ many }) => ({
  cats: many(cats),
}))

export const cats = drizzleSilk(
  t.sqliteTable("cats", {
    id: t.integer().primaryKey({ autoIncrement: true }),
    name: t.text().notNull(),
    birthday: t.integer({ mode: "timestamp" }).notNull(),
    ownerId: t
      .integer()
      .notNull()
      .references(() => users.id),
  })
)

export const catsRelations = relations(cats, ({ one }) => ({
  owner: one(users, {
    fields: [cats.ownerId],
    references: [users.id],
  }),
}))
// @filename: providers/index.ts
import { drizzle } from "drizzle-orm/libsql"
import * as schema from "../schema"

export const db = drizzle(process.env.DB_FILE_NAME ?? "file:local.db", {
  schema,
})
// @filename: services/user.ts
// ---cut---
import { eq } from "drizzle-orm"
import { db } from "../providers"
import { users } from "../schema"

export async function createUser(input: typeof users.$inferInsert) {
  const [user] = await db.insert(users).values(input).returning()
  return user
}

export async function findUsersByName(name: string) {
  return await db.query.users.findMany({
    where: eq(users.name, name),
  })
}

export async function findUserByPhone(phone: string) {
  return await db.query.users.findFirst({
    where: eq(users.phone, phone),
  })
}
// @filename: services/index.ts
export * as userService from "./user"
// @filename: resolver/user.ts
import { mutation, query, resolver } from "@gqloom/core"
import { z } from "zod"
import { users } from "../schema"
import { userService } from "../services"

export const userResolver = resolver({
  usersByName: query(users.$list())
    .input({ name: z.string() })
    .resolve(({ name }) => userService.findUsersByName(name)),

  userByPhone: query(users.$nullable())
    .input({ phone: z.string() })
    .resolve(({ phone }) => userService.findUserByPhone(phone)),

  createUser: mutation(users)
    .input({
      data: z.object({
        name: z.string(),
        phone: z.string(),
      }),
    })
    .resolve(async ({ data }) => userService.createUser(data)),
})
// @filename: resolver/index.ts
// ---cut---
import { query, resolver } from "@gqloom/core"
import { z } from "zod"
import { userResolver } from "./user" // [!code ++]

const helloResolver = resolver({
  hello: query(z.string())
    .input({
      name: z
        .string()
        .nullish()
        .transform((x) => x ?? "World"),
    })
    .resolve(({ name }) => `Hello ${name}!`),
})

export const resolvers = [helloResolver, userResolver] // [!code ++]
```

很好，现在让我们在演练场尝试一下：
```gql title="GraphQL Mutation"
mutation {
  createUser(data: {name: "Bob", phone: "001"}) {
    id
    name
    phone
  }
}
```

这将会得到类型下面的结果：
```json
{
  "data": {
    "createUser": {
      "id": 1,
      "name": "Bob",
      "phone": "001"
    }
  }
}
```

继续尝试找回刚刚创建的用户：
```gql title="GraphQL Query"
{
  usersByName(name: "Bob") {
    id
    name
    phone
  }
}
```

这将会得到类型下面的结果：
```json
{
  "data": {
    "usersByName": [
      {
        "id": 1,
        "name": "Bob",
        "phone": "001"
      }
    ]
  }
}
```