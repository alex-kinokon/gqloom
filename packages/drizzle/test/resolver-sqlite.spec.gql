type Mutation {
  deleteFromPost(where: PostFilters): [PostItem!]!
  deleteFromUser(where: UserFilters): [UserItem!]!
  insertIntoPost(onConflictDoNothing: PostInsertOnConflictDoNothingInput, onConflictDoUpdate: PostInsertOnConflictDoUpdateInput, values: [PostInsertInput!]!): [PostItem!]!
  insertIntoPostSingle(onConflictDoNothing: PostInsertOnConflictDoNothingInput, onConflictDoUpdate: PostInsertOnConflictDoUpdateInput, value: PostInsertInput!): PostItem
  insertIntoUser(onConflictDoNothing: UserInsertOnConflictDoNothingInput, onConflictDoUpdate: UserInsertOnConflictDoUpdateInput, values: [UserInsertInput!]!): [UserItem!]!
  insertIntoUserSingle(onConflictDoNothing: UserInsertOnConflictDoNothingInput, onConflictDoUpdate: UserInsertOnConflictDoUpdateInput, value: UserInsertInput!): UserItem
  updatePost(set: PostUpdateInput!, where: PostFilters): [PostItem!]!
  updateUser(set: UserUpdateInput!, where: UserFilters): [UserItem!]!
}

enum OrderDirection {
  asc
  desc
}

input PostFilters {
  OR: [PostFiltersOr!]
  authorId: SQLiteIntegerFilters
  content: SQLiteTextFilters
  id: SQLiteIntegerFilters
  title: SQLiteTextFilters
}

input PostFiltersOr {
  authorId: SQLiteIntegerFilters
  content: SQLiteTextFilters
  id: SQLiteIntegerFilters
  title: SQLiteTextFilters
}

input PostInsertInput {
  authorId: Int
  content: String
  id: Int
  title: String!
}

input PostInsertOnConflictDoNothingInput {
  target: [PostTableColumn!]
  where: PostFilters
}

input PostInsertOnConflictDoUpdateInput {
  set: PostInsertInput
  setWhere: PostFilters
  target: [PostTableColumn!]!
  targetWhere: PostFilters
}

type PostItem {
  author: UserItem
  authorId: Int
  content: String
  id: Int!
  title: String!
}

input PostOrderBy {
  authorId: OrderDirection
  content: OrderDirection
  id: OrderDirection
  title: OrderDirection
}

enum PostTableColumn {
  authorId
  content
  id
  title
}

input PostUpdateInput {
  authorId: Int
  content: String
  id: Int
  title: String
}

type Query {
  post(limit: Int, offset: Int, orderBy: [PostOrderBy!], where: PostFilters): [PostItem!]!
  postCount(where: PostFilters): Int!
  postSingle(offset: Int, orderBy: [PostOrderBy!], where: PostFilters): PostItem
  user(limit: Int, offset: Int, orderBy: [UserOrderBy!], where: UserFilters): [UserItem!]!
  userCount(where: UserFilters): Int!
  userSingle(offset: Int, orderBy: [UserOrderBy!], where: UserFilters): UserItem
}

input SQLiteIntegerFilters {
  OR: [SQLiteIntegerFiltersOr!]
  eq: Int
  gt: Int
  gte: Int
  inArray: [Int!]
  isNotNull: Boolean
  isNull: Boolean
  lt: Int
  lte: Int
  ne: Int
  notInArray: [Int!]
}

input SQLiteIntegerFiltersOr {
  eq: Int
  gt: Int
  gte: Int
  inArray: [Int!]
  isNotNull: Boolean
  isNull: Boolean
  lt: Int
  lte: Int
  ne: Int
  notInArray: [Int!]
}

input SQLiteTextFilters {
  OR: [SQLiteTextFiltersOr!]
  eq: String
  gt: String
  gte: String
  ilike: String
  inArray: [String!]
  isNotNull: Boolean
  isNull: Boolean
  like: String
  lt: String
  lte: String
  ne: String
  notIlike: String
  notInArray: [String!]
  notLike: String
}

input SQLiteTextFiltersOr {
  eq: String
  gt: String
  gte: String
  ilike: String
  inArray: [String!]
  isNotNull: Boolean
  isNull: Boolean
  like: String
  lt: String
  lte: String
  ne: String
  notIlike: String
  notInArray: [String!]
  notLike: String
}

type StudentToCourseItem {
  courseId: Int
  createdAt: String
  studentId: Int
}

input UserFilters {
  OR: [UserFiltersOr!]
  age: SQLiteIntegerFilters
  email: SQLiteTextFilters
  id: SQLiteIntegerFilters
  name: SQLiteTextFilters
}

input UserFiltersOr {
  age: SQLiteIntegerFilters
  email: SQLiteTextFilters
  id: SQLiteIntegerFilters
  name: SQLiteTextFilters
}

input UserInsertInput {
  age: Int
  email: String
  id: Int
  name: String!
}

input UserInsertOnConflictDoNothingInput {
  target: [UserTableColumn!]
  where: UserFilters
}

input UserInsertOnConflictDoUpdateInput {
  set: UserInsertInput
  setWhere: UserFilters
  target: [UserTableColumn!]!
  targetWhere: UserFilters
}

type UserItem {
  age: Int
  courses: [StudentToCourseItem!]!
  email: String
  id: Int!
  name: String!
  posts: [PostItem!]!
}

input UserOrderBy {
  age: OrderDirection
  email: OrderDirection
  id: OrderDirection
  name: OrderDirection
}

enum UserTableColumn {
  age
  email
  id
  name
}

input UserUpdateInput {
  age: Int
  email: String
  id: Int
  name: String
}